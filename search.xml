<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>判断质数</title>
      <link href="/2021/12/19/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86/"/>
      <url>/2021/12/19/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>以前刚开始学二分的时候，只知道二分就是一半一半的分下去，对于边界问题一直都不是很懂，之前为了避免这问题想着用一个对拍程序来查看自己写的是否是对的，但是想了想还是要想一个正解。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h2><p>二分时主要是防止l和r的值都不发生改变，使得程序进入了死循环。</p><p>接下来是本人的一点理解。</p><h2 id="本人理解："><a href="#本人理解：" class="headerlink" title="本人理解："></a>本人理解：</h2><h2 id="整数二分："><a href="#整数二分：" class="headerlink" title="整数二分："></a>整数二分：</h2><h3 id="找最大值："><a href="#找最大值：" class="headerlink" title="找最大值："></a>找最大值：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(mid&lt;=x) l=mid;<span class="comment">//如果mid&lt;=x，那么最优解一定不在左区间</span></span><br><span class="line"><span class="keyword">else</span> r=mid<span class="number">-1</span>;<span class="comment">//如果mid&gt;x，那么x即其右区间都无解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为防止mid取到l或r时死循环</span></span><br><span class="line">mid=(l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;<span class="comment">//取不到l,防止l=mid时死循环</span></span><br></pre></td></tr></table></figure><h3 id="找最小值："><a href="#找最小值：" class="headerlink" title="找最小值："></a>找最小值：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(mid&lt;=x) r=mid;<span class="comment">//如果mid&gt;=x，那么最优解一定不在右区间</span></span><br><span class="line"><span class="keyword">else</span> l=mid+<span class="number">1</span>;<span class="comment">//如果mia&lt;x，那么x即其左区间无解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为防止mid取到l或r时死循环</span></span><br><span class="line">mid=(l+r)&gt;&gt;<span class="number">1</span>;<span class="comment">//取不到r，防止r=mid时陷入死循环</span></span><br></pre></td></tr></table></figure><h2 id="实数二分："><a href="#实数二分：" class="headerlink" title="实数二分："></a>实数二分：</h2><p>不用考虑死循环的情况，主要需要考虑精度问题。</p><h2 id="三分求单峰函数极值："><a href="#三分求单峰函数极值：" class="headerlink" title="三分求单峰函数极值："></a>三分求单峰函数极值：</h2><p>只适用于有单调性的函数，如$y=x^2$类似的二次函数，通过三分确定趋势，从而确定最终极值。</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断质数</title>
      <link href="/2021/12/19/%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0/"/>
      <url>/2021/12/19/%E5%88%A4%E6%96%AD%E8%B4%A8%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>质数定义：一个数只能被1和自己整除，即因数只有1和本身</p><h2 id="1-试除法-O-sqrt-N"><a href="#1-试除法-O-sqrt-N" class="headerlink" title="1.试除法 $O(\sqrt{N})$"></a>1.试除法 $O(\sqrt{N})$</h2><p>通过定义，我们清楚地明白，对于一个数n，我们只要判断它的因数有几个，就可以判断它是不是质数了。那么我们只要判断n能否整除2到n-1这个区间中的一个整数即可判断。</p><p>但是在数据过大时会有超时的现象，这时我们可以进行优化。</p><p>一个数n若能被a整除(a不为1或n)，则一定存在一个a使得a小于$\sqrt{n}$。</p><p>n/a=b（a，b均为整数）</p><p>证：如果a$\leq$$\sqrt{n}$，显然成立，如果a大于$\sqrt{n}$，则b一定小于$\sqrt{n}$，假设成立。</p><p>综上所述，一个不是质数的数一定存在一个小于等于$\sqrt{n}$的因数。</p><p>所以在判断一个数是否是指数是，只需判断[2,\sqrt{n}]是否存在一个数为n的因数，即是否存在一个数能整除n即可。</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,a,b;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        b=<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=a/i;i++)&#123;<span class="comment">//i&lt;=a/i可以防止i*i过大，如果循环判断条件为i*i&lt;=a，会出现i*i爆的现象</span></span><br><span class="line">            <span class="keyword">if</span>(a%i==<span class="number">0</span>) &#123;</span><br><span class="line">            b=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">1</span>&amp;&amp;a!=<span class="number">1</span>) cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;No&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Eratoshenes-埃氏筛-："><a href="#2-Eratoshenes-埃氏筛-：" class="headerlink" title="2.Eratoshenes(埃氏筛)："></a>2.Eratoshenes(埃氏筛)：</h2><p>用试除法在只判断一个数时，$O(N)$的复杂度自然是较优的，但是当判断的数较多时，显然是会超时的，这里介绍一下埃氏筛。</p><p>埃氏筛是一种复杂度接近线性筛的算法。 时间复杂度$O(NloglogN)$</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>通过对质数概念的讲解，我们清晰地明白，一个数是质数，当且仅当它的因数只有1以及本身。那么换种说法，相当于一个数如果是质数，那么它一定是小于它的某个数（除1以外）的倍数。那么代码就很好写了，我们只要把所有&lt;=N的数的倍数都标记成非质数即可。</p><p>对于这个算法，我们可以进行进一步优化。在讲解试除法时，我们明白，如果一个数a不是质数，那么它一定有一个小于$\sqrt{a}$的因数b，并且它一定是这个因数b大于或等于$\sqrt{b}$的倍数，所以对于一个非质数a，一定有一个小于$\sqrt{a}$的因数b，使得$b \times c$等于a，（c&gt;=b）所以对于第二层循环我们就可以进行优化。只要从$b^2$开始即$b \times b$开始筛即可。</p><h3 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,ans;</span><br><span class="line"><span class="keyword">bool</span> a[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shai</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=N;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=N/i;j++)&#123;</span><br><span class="line">            a[i*j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-线性筛"><a href="#3-线性筛" class="headerlink" title="3.线性筛"></a>3.线性筛</h2><p>埃氏筛之所以会有重复筛的情况，就是因为一个数的因数搭配不唯一，一个人数有多种因数搭配。</p><p>如：$16=2 \times 8=4 \ times 4=8 \times 2$，虽然我们通过一部分优化省去了一些不必要的循环，但是还是没有达到真正的线性筛。那么重要的就是要找到唯一的可以确定一个数的因数搭配的方法，这就是用质因数来确认一个数。</p><p>如$16=2 \times 2 \times 2 \times 2$</p><p>$12=2 \times 2 \times 3$</p><p>$24=2 \times 2 \times 2 \times 3$</p><p>那么思路就很清晰了，分解质因数中每个数的质因子一定都是质数，质数的最小质因子就是它本身。</p><p>算法思路：运用一个整型数组v[N]来表示每个数的最小质因子，初始时全部为0.再运用一个数组prime[]，来表示第几个质数是多少。</p><h3 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h3><p>第一层循环i从2到n，表示目前在筛的数，如果v[i]为0，则表示i没被小于i的数筛过，因此i为质数，此时v[i]=i,prime[++m]=i;第二层循环从prime[1]到prime[m]，及现在筛出来的质数。如果prime[i]&gt;v[i]，即该质数大于i的最小质因子，此时没有进行的必要，因为之后或者之前肯定已经筛过了，这样会导致重复。此时直接break即可，如果i$\times$prime[m]超出了n的范围，那么也没必要再运行了，直接break即可。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>线性筛通过判断最小质因子是否为本身来判断质数。之后在循环中更新后续数的最小质因子，以此来维护整个数列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e8</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> v[N];</span><br><span class="line"><span class="keyword">int</span> pri[N],cnt;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shai</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!v[i]) &#123;v[i]=i;pri[++cnt]=i;&#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pri[j]&gt;v[i]||pri[j]&gt;n/i) <span class="keyword">break</span>;</span><br><span class="line">            v[i*pri[j]]=pri[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">shai</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pri[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断质数</title>
      <link href="/2021/12/19/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/"/>
      <url>/2021/12/19/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
      
        <content type="html"><![CDATA[<h2 id="1-向上标记法"><a href="#1-向上标记法" class="headerlink" title="1.向上标记法"></a>1.向上标记法</h2><p>最朴素的求最近公共祖先的方法，两个子结点同时向上一个一个的跳，标记已经跳过的点，如果有一个点跳到了已经标记过的点，那么就说明这个点就是最近公共祖先。可以自己简单的推一下，查询的时间复杂度为 $ O(n) $ 。</p><h2 id="2-倍增"><a href="#2-倍增" class="headerlink" title="2.倍增"></a>2.倍增</h2><p>总思路：用类似于二进制拆分的思想。</p><p>首先我们先理清楚二进制数的特点，对于一个数$2^n$，我们可以用$2^0,2^1…2^n-1$，来表示出任何一个小于$2^n$的数。</p><h3 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h3><p>$8=1000,=2^3$</p><p>$7=0111,=2^2+2^1+2^0$</p><p>$6=0110,=2^2+2^1$</p><p>$5=0101,=2^2+2^0$</p><p>$4=0100,=2^2$</p><p>$3=0011,=2^1+2^0$</p><p>$2=0010,=2^1$</p><p>$1=0001,=2^0$</p><p>下面来介绍一下算法的思路，来解释一下为什么与二进制数的拆分有关系。</p><h3 id="算法思路："><a href="#算法思路：" class="headerlink" title="算法思路："></a>算法思路：</h3><p>当x与y在不同深度时，最近公共祖先肯定不会是深度大的那个结点，所以说，我们可以将x与y调整到同一深度，将深度大的点不断往上跳，直到两个点深度相同。这与求两个点的最近公共祖先是等效的。</p><p>那么要怎么样让结点小的点往上跳呢，首先，我们要进行一遍处理，预处理出每个节点的第$2^k$的父结点。这样子在往上跳的时候，就可以直接跳到2的k次方。</p><p>那么我们首先将深度大的点不断向上跳，直到两个点深度相同。（具体可以看代码，这里就要用到二进制拆分了。）</p><p>这里如果要推的话有个推理，当求两个点（如x和y）的最近公共祖先时，如果x或y不是最近公共祖先那么求x和y的最近公共祖先等效于求x的父结点和y的父结点的最近公共祖先。</p><p>因此我们可以推出，当x与y的$2^k$祖先不是最近公共祖先时，我们可以直接将问题改为求x的$2^k$的父结点和y的$2^k$的父结点的最近公共祖先。</p><p>那么当x和y的$2^k$的祖先相同时，我们就不往上跳，当x与y的$2^k$的祖先不同时，我们就向上跳$2^k$，最后可以保证跳完后x的祖先或y的祖先即为x和y的最近公共祖先。</p><p>而上面讲述二进制拆分就是为了讲述如何保证不跳少了。</p><p>比如说如果x和y的最近公共祖先是x的第7个父结点时，刚开始从$2^k$，一支循环到$2^3$，发现x的第8个父结点与y的第8个父结点是相同的，所以不往上跳，而剩下的$2^2$发现父结点不同，向上跳4，$2^1$，发现父结点不同，向上跳2，最后发现父结点相同了不在往上跳。那么此时x以及y的父结点就是要求的最近公共祖先。</p><h2 id="3-树链剖分"><a href="#3-树链剖分" class="headerlink" title="3.树链剖分"></a>3.树链剖分</h2><p>树链剖分有很多种，这里讲的是重链剖分，简单的来说是对于每个结点来说，将他的子儿子中子树的节点数最多的子儿子作为重儿子（等图片上来后更清楚）。</p><p>重链剖分：用子节点个数来确定重儿子和轻儿子，且将连续的重儿子连成一条链，使得树被分为多条链。</p><h3 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h3><p>两次dfs，第一次，找出重儿子，深度，父节点。第二次dfs，确定点的dfn序和rnk序，以及每个点的重顶点。</p><h3 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h3><p>若在同一条重链上，则深度小的点为最近公共祖先。若不在，则将重顶点的深度大的点通过跳到链顶的方式，直到两个点到同一条重链上。</p><h3 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h3><p>这里是我的不严谨证明：</p><p>若两个节点不在同一条重链上，则最近公共祖先（下面以lca代替）不可能在链顶深度大的重链中，此时，求x与y的lca与x与top[y]的lca相同，同理x与f[top[y]]的lca相同，以此直到在同一条重链中。</p><h2 id="4-Tarjan"><a href="#4-Tarjan" class="headerlink" title="4.Tarjan"></a>4.Tarjan</h2><p>还不会</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/12/04/hello-world/"/>
      <url>/2021/12/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线段树模板</title>
      <link href="/2021/11/06/2021-11-06-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E7%89%88(%E6%B4%9B%E8%B0%B7P3372)/"/>
      <url>/2021/11/06/2021-11-06-%20%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E7%89%88(%E6%B4%9B%E8%B0%B7P3372)/</url>
      
        <content type="html"><![CDATA[<!-- wp:heading {"level":3} --><h3>概述：</h3><!-- /wp:heading --><!-- wp:paragraph --><p>线段树是算法竞赛中常用的数据结构（虽然考场中很少用，毕竟调起来麻烦，区间求和用树状树组还是更加方便代码也短）。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>线段树可以在O(logN)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作。简略的描述一下算法思路，线段树是一个二叉树，树的每一个节点存储的都是一个区间内的值（根据具体的题目而定），每个父结点的值由两个子结点的值决定。</p><!-- /wp:paragraph --><!-- wp:paragraph --><p>但是普通的二分思想并不能体现线段树的精髓所在，线段树的精髓就在于它的懒标记，具体往下看。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>算法的实现：</h3><!-- /wp:heading --><!-- wp:paragraph --><p>这里以洛谷P3372的区间求和为例</p><!-- /wp:paragraph --><!-- wp:heading {"level":4} --><h4>建树（build）</h4><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>struct segmentTree&#123;    int l,r; //查询的区间范围    long long sum ,lz; //区间和，懒标记&#125;t&#91;N&lt;&lt;2];//要开4*N的大小void build(int l,int r,int tr)&#123;    t&#91;tr].l=l;t&#91;tr].r=r;    if(l==r) &#123;t&#91;tr].sum=a&#91;l];return;&#125; //如果区间内只有一个树，则赋值，返回    int mid=(l+r)&gt;&gt;1;    build(l,mid,pl); //建左区间    build(mid+1,r,pr); //建有区间    pushup(tr); //关键操作&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>上放（pushup）</h4><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>void pushup(int tr)&#123;    t&#91;tr].sum=t&#91;pl].sum+t&#91;pr].sum; //由两个子结点的值更新父结点的值&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>下放（pushdown）</h4><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>void pushdown(int tr)&#123;    if(t&#91;tr].lz)&#123;        t&#91;pl].sum+=t&#91;tr].lz*(t&#91;pl].r-t&#91;pl].l+1);//左儿子的值加上懒标记的值*区间内数的个数        t&#91;pr].sum+=t&#91;tr].lz*(t&#91;pr].r-t&#91;pr].l+1);//右儿子的值加上懒标记的值*区间内树的个数        t&#91;pl].lz+=t&#91;tr].lz;//懒标记下放        t&#91;pr].lz+=t&#91;tr].lz;//懒标记下放        t&#91;tr].lz=0;//将父结点的懒标记清零    &#125;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>更新（update）</h4><!-- /wp:heading --><!-- wp:paragraph --><p>update中的pushup()是我当时学习该算法时的没理解的一个地方，并不是直接更新每个结点的值，而是最后通过pushup()来更新父结点</p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>void update(int l,int r,int tr,int num)&#123;    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r) &#123;t&#91;tr].sum+=num*(t&#91;tr].r-t&#91;tr].l+1);t&#91;tr].lz+=num;return;&#125;    pushdown(tr);//上一行是指如果该区间在查询区间内，则更新该区间值即懒标记，并且返回。（因为有懒标记），如果不包含则懒标记下放    int mid=(t&#91;tr].l+t&#91;tr].r)&gt;&gt;1;//二分    if(l&lt;=mid) update(l,r,pl,num); //如果左儿子一部分在查询区间内，更新左儿子    if(mid&lt;r) update(l,r,pr,num); //如果右儿子一部分在查询区间内，更新右儿子    pushup(tr);//关键的一步&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>查询（query）</h4><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>long long query(int l,int r,int tr)&#123;    long long ans=0;    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r) return t&#91;tr].sum;    pushdown(tr);    int mid=(t&#91;tr].l+t&#91;tr].r)&gt;&gt;1;    if(l&lt;=mid) ans+=query(l,r,pl);    if(mid&lt;r) ans+=query(l,r,pr);    return ans;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>例题与示例程序：</h3><!-- /wp:heading --><!-- wp:heading {"level":4} --><h4>1.区间求和</h4><!-- /wp:heading --><!-- wp:paragraph --><p>洛谷<a href="https://www.luogu.com.cn/problem/P3372">P3372 </a></p><!-- /wp:paragraph --><!-- wp:paragraph --><p></p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#define pl tr&lt;&lt;1#define pr tr&lt;&lt;1|1using namespace std;const int N=1e5+10;int n,m,a&#91;100010],x,y,k,q;struct segmentTree&#123;    int l,r,lz;    long long sum;&#125;t&#91;N&lt;&lt;2];void pushup(int tr)&#123;    t&#91;tr].sum=t&#91;pl].sum+t&#91;pr].sum;&#125;void pushdown(int tr)&#123;    if(t&#91;tr].lz)&#123;        t&#91;pl].sum+=t&#91;tr].lz*(t&#91;pl].r-t&#91;pl].l+1);        t&#91;pr].sum+=t&#91;tr].lz*(t&#91;pr].r-t&#91;pr].l+1);        t&#91;pl].lz+=t&#91;tr].lz;        t&#91;pr].lz+=t&#91;tr].lz;        t&#91;tr].lz=0;    &#125;&#125;void build(int l,int r,int tr)&#123;    t&#91;tr].l=l,t&#91;tr].r=r;    if(l==r)&#123;t&#91;tr].sum=a&#91;r];return;&#125;    int mid=(l+r)&gt;&gt;1;    build(l,mid,pl);    build(mid+1,r,pr);    pushup(tr);&#125;void update(int l,int r,int tr,int num)&#123;    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r) &#123;t&#91;tr].sum+=num*(t&#91;tr].r-t&#91;tr].l+1);t&#91;tr].lz+=num;return;&#125;    pushdown(tr);    int mid=(t&#91;tr].r+t&#91;tr].l)&gt;&gt;1;    if(l&lt;=mid)update(l,r,pl,num);    if(mid&lt;r)update(l,r,pr,num);    pushup(tr);&#125;long long query(int l,int r,int tr)&#123;    long long ans=0;    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r) return t&#91;tr].sum;    pushdown(tr);    int mid=(t&#91;tr].r+t&#91;tr].l)&gt;&gt;1;    if(l&lt;=mid) ans+=query(l,r,pl);    if(mid&lt;r) ans+=query(l,r,pr);    return ans;&#125;int main()&#123;    scanf("%d%d",&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)scanf("%d",&amp;a&#91;i]);        build(1,n,1);    for(int i=1;i&lt;=m;i++)&#123;        scanf("%d%d%d",&amp;q,&amp;x,&amp;y);        if(q==1)&#123;            scanf("%d",&amp;k);            update(x,y,1,k);        &#125;        else&#123;            printf("%lld\n",query(x,y,1));        &#125;    &#125;    return 0;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":4} --><h4>2.区间求乘积</h4><!-- /wp:heading --><!-- wp:paragraph --><p>洛谷<a href="https://www.luogu.com.cn/problem/P3373">P3373</a></p><!-- /wp:paragraph --><!-- wp:code --><pre class="wp-block-code"><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#define pl tr&lt;&lt;1#define pr tr&lt;&lt;1|1using namespace std;const int N=1e5+10;int n,m,p,x,y,k,q;int a&#91;N];struct segmentTree&#123;    int l,r;    long long sum,add=0,mul=1;//add=加,mul=乘&#125;t&#91;N&lt;&lt;2];void pushup(int tr)&#123;    t&#91;tr].sum=(t&#91;pl].sum+t&#91;pr].sum)%p;&#125;void pushdown(int tr)&#123;    t&#91;pl].sum=(t&#91;tr].add*(t&#91;pl].r-t&#91;pl].l+1)%p+(t&#91;pl].sum*t&#91;tr].mul)%p)%p;    t&#91;pr].sum=(t&#91;tr].add*(t&#91;pr].r-t&#91;pr].l+1)%p+(t&#91;pr].sum*t&#91;tr].mul)%p)%p;    t&#91;pl].add=(t&#91;tr].mul*t&#91;pl].add%p+t&#91;tr].add)%p;    t&#91;pl].mul=t&#91;tr].mul*t&#91;pl].mul%p;    t&#91;pr].add=(t&#91;tr].mul*t&#91;pr].add%p+t&#91;tr].add)%p;    t&#91;pr].mul=t&#91;tr].mul*t&#91;pr].mul%p;    t&#91;tr].add=0;t&#91;tr].mul=1;&#125;void build(int l,int r,int tr)&#123;    t&#91;tr].l=l;t&#91;tr].r=r;    if(l==r) &#123;t&#91;tr].sum=a&#91;l];return;&#125;    else&#123;        int mid=(l+r)&gt;&gt;1;        build(l,mid,pl);        build(mid+1,r,pr);        pushup(tr);    &#125;&#125;void update1(int l,int r,int tr,int k)&#123;//add    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r)&#123;        t&#91;tr].sum=(t&#91;tr].sum+k*(t&#91;tr].r-t&#91;tr].l+1)%p)%p;        t&#91;tr].add=(t&#91;tr].add+k%p)%p;        return;    &#125;    pushdown(tr);    int mid=(t&#91;tr].l+t&#91;tr].r)&gt;&gt;1;    if(l&lt;=mid) update1(l,r,pl,k);    if(mid&lt;r) update1(l,r,pr,k);    pushup(tr);&#125;void update2(int l,int r,int tr,int k)&#123;//mul    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r)&#123;        t&#91;tr].sum=(t&#91;tr].sum*k)%p;        t&#91;tr].add=(t&#91;tr].add*k)%p;        t&#91;tr].mul=(t&#91;tr].mul*k)%p;        return;    &#125;    pushdown(tr);    int mid=(t&#91;tr].l+t&#91;tr].r)&gt;&gt;1;    if(l&lt;=mid) update2(l,r,pl,k);    if(mid&lt;r) update2(l,r,pr,k);    pushup(tr);&#125;long long query(int l,int r,int tr)&#123;    long long ans=0;    if(l&lt;=t&#91;tr].l&amp;&amp;t&#91;tr].r&lt;=r) return t&#91;tr].sum;    int mid=(t&#91;tr].l+t&#91;tr].r)&gt;&gt;1;    pushdown(tr);    if(l&lt;=mid) ans+=query(l,r,pl);    if(mid&lt;r) ans+=query(l,r,pr);    return ans%p;&#125;int main()&#123;    scanf("%d%d%d",&amp;n,&amp;m,&amp;p);    for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a&#91;i]);    build(1,n,1);    for(int i=1;i&lt;=m;i++)&#123;        scanf("%d%d%d",&amp;q,&amp;x,&amp;y);        if(q==1)&#123;            scanf("%d",&amp;k);            update2(x,y,1,k);        &#125;        else if(q==2)&#123;            scanf("%d",&amp;k);            update1(x,y,1,k);        &#125;        else &#123;            printf("%lld\n",query(x,y,1));        &#125;    &#125;    return 0;&#125;</code></pre><!-- /wp:code -->]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021-10-22</title>
      <link href="/2021/10/22/2021-10-22-%E5%86%B3%E5%BF%83/"/>
      <url>/2021/10/22/2021-10-22-%E5%86%B3%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<h1 id="2021-10-22-12-48-20-目送他人出发NOI，在此下定决心，明年，一定。"><a href="#2021-10-22-12-48-20-目送他人出发NOI，在此下定决心，明年，一定。" class="headerlink" title="2021.10.22.12:48:20 目送他人出发NOI，在此下定决心，明年，一定。"></a>2021.10.22.12:48:20 目送他人出发NOI，在此下定决心，明年，一定。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> OI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OJ1223猴子选大王题解</title>
      <link href="/2021/10/18/2021-10-18-%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B/"/>
      <url>/2021/10/18/2021-10-18-%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p> <em>猴群一共有 n 只猴子，现在它们要选出大王，具体方法是：所有猴子按位置 1- n 围坐成一圈，从第 1 个位置开始按顺序 1-m 报数，“1、2、3……m - 1、m”。报到 m 的猴子就要离开此圈，它下一个位置重新 1-m 报数。这样依次下来，直到只剩下最后一只猴子，则该猴子为大王。</em></p><p> <em>你作为一只聪明的猴子，为了成为大王，最开始要坐在哪个位置呢？</em></p><p> <em>输入</em></p><p> <em>一行两个正整数，即 n、m。</em></p><p> <em>输出</em></p><p> <em>一个整数，即你最开始坐的位置（猴王位置）。</em></p><p>有的人是第一次见这种题目，这题其实是经典的约瑟夫问题。故事背景什么的网上都可以搜到，这里就不再赘述。下面来讲解题方法。</p><p> <em>示例输入 $  10$ $  3$</em><br> <em>输出$  4$</em></p><h2 id="1-模拟法"><a href="#1-模拟法" class="headerlink" title="1.模拟法"></a>1.模拟法</h2><p> 由题意来进行模拟，定义一个变量为报的数，一个变量为报到的人，每次将报到3的人退出。在python里可以开一个列表，然后遍历列表，将报到3的人退出列表，如果遍历列表长度大于1，就再次遍历，直到列表里只剩下一个数（大概是这样，python也不是很会，差不多）。</p><p> 这种能过数据较小的点，在题目里显然是不能拿到满分的。</p><h2 id="2-公式"><a href="#2-公式" class="headerlink" title="2.公式"></a>2.公式</h2><p> 我们将每一次报数的顺序排出来，每有一个人报到3我们就重新开始报数，我们将每一次报数的顺序写出来，如下图：</p><p><img src="https://unclezhou.daihan.top/wp-content/uploads/2021/11/2021-10-18_%E7%8C%B4%E5%AD%90%E9%80%89%E5%A4%A7%E7%8E%8B.png"></p><p> 这里我们将第一个报到的人的下标记作0，方便后面的计算。</p><p> 我们看看全局可以看到每一次下一轮开始报数的人一定是这一轮报到的人的下一个，这很显然是显而易见的。应该没问题吧。</p><p> 那么我们可以从这一行所报的数字的位置而推断出上一行该数字的位置。就第10行为例好了，这个数是第10行的第一个数，那么就是上一行的报到的人的下一个，那么就应该是在第9行的第3个报到的人的后面，就是第九行第4个人，下标为3。</p><p> 那么新的问题来了 有两个数按这个顺序排列 $10，4，10，4，10…，10，4$；那么第4个数第一次出现是在第1个数的位置还是在第2个数的位置呢？很明显除以数的个数取余（模）一下就可以找到对应的关系了，这里通过下标来表示，置于下表为什么要从零开始下面还会再讲，那么我们通过下标$3%2$即可获得它在第9层的下标,所以4在第9行第一次出现是在2这个位置，下标为1。知道了这个就可以让我们继续推它在上一层的位置了。推到第一层之后那么猴王在第一层的位置就确定了。</p><p> 继续按照这样子推下去，4在第9层第一次出现是第2个数那么他在第8层就应该是$3+2=5$，第5个数，第8层一共有3个数，所以通过他的下标4%3=1即可获取他在第8层的下标；</p><p> 如果下标从1开始的话基本步骤还是一样，只是当下标%数的个数时当余数为0时要进行特殊处理，第一次在0出现那么一共有n个数，所以第一次出现是在第n个数，由此看出下标从1开始需要进行特判，所以一般不采用这种方法。而如果下标从0开始就不会有这种情况，只需要最后求出最后一个人在第一轮的下标时加1就能获得该数。</p><p> 所以说我们一直从下往上递推（指循环）就可以了，若有n个数，报到i的人退出，循环从下往上，将n-1层看成第2层，因为第n-1层有2个数方便计算，将第1层堪称第n层。因此层数=数的个数然后循环从第2层开始，计算公式：数在下一层的下标=（数在这一层的下标+i）%层数；</p><p> 猴王在第1层下标为0，套入公式即可算出它在第n层也就是第一轮的下标，那么他的位置也就是下标加1。答案就出来了。</p><p> <strong>（第一版）待完善，等下次有时间再说。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux对拍c++</title>
      <link href="/2021/10/18/2021-11-21-linux%E5%AF%B9%E6%8B%8Dc++/"/>
      <url>/2021/10/18/2021-11-21-linux%E5%AF%B9%E6%8B%8Dc++/</url>
      
        <content type="html"><![CDATA[<!-- wp:heading {"level":3} --><h3>概述</h3><!-- /wp:heading --><!-- wp:paragraph --><p><strong>以前对于对拍感觉不是很必要，但是今天在刷二分题目的时候对于二分的边界一直都不是很懂。所以在思考如何考虑这个问题的时候，想到另辟蹊径。既然我自己不知道二分是不是写对了，就让电脑来让我判断。所以我决定去网上学习对拍。</strong></p><!-- /wp:paragraph --><!-- wp:paragraph --><p>  <strong>      但是网上的对拍虽然可以实现判断程序的对错，但是却不能给出确切的每个程序的运行时间。在网上找的一些是用了clock()函数，然而这在程序中引入system()函数时，无法判断system()函数的运行时间，说人话就是clock()函数只能判断该程序中的函数的运行速度，运行其他程序的函数的时间不计算在时间内。所以我又找了许久，终于找到了一个勉强能用的函数gettimeofday</strong></p><!-- /wp:paragraph --><!-- wp:paragraph --><p>     <strong> 这个函数会计算从1970年1月1日00:00到现在的时间跨度(受不同时区影响)，函数的具体使用方式不是文章的主题，就先不赘述了。（事实是我这个蒟蒻不会写）</strong></p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>实现方法:</h3><!-- /wp:heading --><!-- wp:paragraph --><p>以洛谷P1102这道二分题为例。</p><!-- /wp:paragraph --><!-- wp:heading {"level":3} --><h3>暴力程序:</h3><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>#include &lt;iostream&gt;using namespace std;long long c&#91;200010];long long d;int main()&#123;    long long a,b;    scanf("%lld%lld",&amp;a,&amp;b);    for(int i=0;i&lt;a;i++)&#123;        scanf("%lld",&amp;c&#91;i]);    &#125;    for(int i=0;i&lt;a;i++)&#123;        for(int j=0;j&lt;a;j++)&#123;            if(c&#91;i]-c&#91;j]==b) d++;        &#125;    &#125;    printf("%lld",d);    return 0;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>标程：</h3><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;long long n,c,a&#91;200010],ans=0;int main()&#123;    scanf("%lld%lld",&amp;n,&amp;c);    for(int i=1;i&lt;=n;i++) scanf("%lld",&amp;a&#91;i]);    sort(a+1,a+1+n);    for(int i=1;i&lt;=n;i++)&#123;        int l=1,r=n,j=a&#91;i];        while(l&lt;r)&#123;            int mid=(l+r)&gt;&gt;1;            if(a&#91;i]-a&#91;mid]&lt;=c)&#123;                r=mid;            &#125;            else l=mid+1;        &#125;        int l1=1,r1=n;        while(l1&lt;r1)&#123;            int mid=(l1+r1)&gt;&gt;1;            if(a&#91;i]-a&#91;mid]&gt;=c)&#123;                l1=mid+1;            &#125;            else r1=mid;        &#125;        ans+=l1-l;    &#125;    printf("%lld",ans);    return 0;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>造数据：</h3><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>#include &lt;bits/stdc++.h&gt;using namespace std;const int mod=5e4; //数据大点可以发现明显超时，开小点就做个示范看看运行时间。const int m1=1e3;int main()&#123;    srand(time(0)); // c++输出随机数，不加这一行就会生成全部一样的数    int n=rand()%mod+1;    int m=rand()%m1;    printf("%d %d ",n,m);    for(int i=1;i&lt;=n;++i)&#123;        printf("%d ",rand()%m1);    &#125;    return 0;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>用来对拍的程序：</h3><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>#include &lt;bits/stdc++.h&gt;#include &lt;sys/time.h&gt;using namespace std;int main()&#123;    struct timeval s1,s,e; //这个函数的格式就是这样    int t1,t2;    for(int i=1;i&lt;=1000;++i)&#123;        system("./make &gt;date.in");//重定向输出        gettimeofday(&amp;s1,NULL);        system("./b &lt;date.in &gt;1.out"); //重定向输入输出        gettimeofday(&amp;s,NULL);        system("./baoli &lt;date.in &gt;2.out");//重定向输入输出        gettimeofday(&amp;e,NULL);        t1=(s.tv_sec-s1.tv_sec)*1000+(s.tv_usec-s1.tv_usec)/1000; //把时间转化成毫秒        t2=(e.tv_sec-s.tv_sec)*1000+(e.tv_usec-s.tv_usec)/1000; //把时间转化成毫秒        if(system("diff 1.out 2.out"))&#123;            puts("WA");            return 0;        &#125;        else printf("AC,test point #%d,btime %dms ,baotime %dms\n",i,t1,t2);                                   //分别输出数据的组数，第一个程序的运行时间，第二个程序的运行时间。    &#125;&#125;</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>自动编译加运行的bash脚本：</h3><!-- /wp:heading --><!-- wp:code --><pre class="wp-block-code"><code>#! /bin/bashg++ baoli.cpp -o baolig++ b.cpp -o bg++ pai.cpp -o paig++ make.cpp -o make./pai</code></pre><!-- /wp:code --><!-- wp:heading {"level":3} --><h3>总结</h3><!-- /wp:heading --><!-- wp:paragraph --><p>大体上就是这样的，希望看到这篇文章的人以后二分再也不用担心</p><!-- /wp:paragraph -->]]></content>
      
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2021/10/15/2021-10-15-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2021/10/15/2021-10-15-%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>1<font size =10><center> 超硬核进制转换</p><p>$　$<strong>众所周知，将二进制转化为十进制数十分的方便，而用十进制转换为二进制时，有一种方法，十分的方便．只需要将原数不断除以二的余数写下来后倒着遍历一遍就是二进制了。</strong></p><h1 id="例如-："><a href="#例如-：" class="headerlink" title="例如 ："></a><em>例如</em> ：</h1><p>   $ 　　$$7/2=3…1 $</p><p>   $ 　　$$3/2=1…1 $</p><p> $ 　　$$1/2=0…1 $</p><p> $ 　　$$所以7的二进制表示为111$</p><p>  原理：</p><p>$7的二进制表达为111$  </p><p>$7=111B$</p><p>$7=1\times2^2+1\times2^1+1\times2^0$</p><p>$7/2=1\times2^2/2+1\times2^1/2+1\times2^0/2$</p><p>##明显前面两项可以被除尽，而最后的$1\times2^0/2$无法被整除，因此会存在余数1，这个1就是$1\times2^0$，而$2^0$=1，所以$2^0$对取余数无影响,这个余数1就是该幂的系数1。所以这个1就是二进制的最后一位,那么去掉余数后原数变为3</p><p> $3=1\times2^1+1\times2^0$</p><p>$同理得余数为1$</p><p>$1=1*2^0$</p><p>这个例子可能还是有点难以理解，我们来看看其他进制如16进制<br>$首先16进制转10进制$</p><p>$A9=10\times16^1+9\times16^0=169$</p><p>$169=A9$ </p><p>$169/16=10…9$</p><p>$10/16=0…10$</p><p>$从下往上数，10为A，所以是A9$</p><p>$A9=10\times16^1+9\times16^0=169$</p><p>$169=10\times16^1+9\times16^0$</p><p>$169/16=10\times16^1/16+9\times16^0/16$</p><p>##$9\times16^0$无法被整除，因此余数为9（$16^0=1$,所以9$\times1%16=9$）这个余数9也就是系数9</p><p>$10=10\times16^0$</p><p>$10/16=10\times16^0/16$</p><p>##$余数为10，又因为在十六进制中10为A，所以为A9$</p><p>$每一步得出来的都是最后面的系数$<br>$所以把系数从下往上数加起来即可获得最后的数$</p><p>所以$169=A9$</p><h1 id="以上"><a href="#以上" class="headerlink" title="以上"></a>以上</h1><h4 id="希望能够理解"><a href="#希望能够理解" class="headerlink" title="希望能够理解"></a>希望能够理解</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021.10.05集训</title>
      <link href="/2021/10/05/2021-10-05-%E9%9B%86%E8%AE%AD%E4%BB%A3%E7%A0%812021.10.5/"/>
      <url>/2021/10/05/2021-10-05-%E9%9B%86%E8%AE%AD%E4%BB%A3%E7%A0%812021.10.5/</url>
      
        <content type="html"><![CDATA[<p>T1<br>Stone.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> ans=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"><span class="keyword">double</span> a[<span class="number">100010</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen(&quot;stone.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//freopen(&quot;stone.ans&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=((a[i])/(a[i]+a[<span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line">ans=ans+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.6lf&quot;</span>,ans);</span><br><span class="line"><span class="comment">//fclose(stdin);</span></span><br><span class="line"><span class="comment">//fclose(stdout);</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>假期结束</title>
      <link href="/2021/10/05/2021-10-07-%E7%BB%93%E6%9D%9F/"/>
      <url>/2021/10/05/2021-10-07-%E7%BB%93%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<p><strong>已经结束了</strong></p><p>记个日程</p><p><strong>10.1</strong></p><p>休息</p><p><strong>10.2-10.3</strong></p><p>上午睡觉下午上课</p><p><strong>10.4-10.5</strong></p><p>一整天上课</p><p><strong>10.6</strong></p><p>起床后知道不用上课，想写作业结果却没有，搞了一天的博客，对，就是<strong>这个</strong></p><p><strong>10.7</strong></p><p>已经结束了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
